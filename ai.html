<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Playground/toai.chat</title>
  
  <!-- 引入UIKit和TailwindCSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uikit@3.16.19/dist/css/uikit.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.16.19/dist/js/uikit.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uikit@3.16.19/dist/js/uikit-icons.min.js"></script>

    <!-- 引入marked和highlight.js -->
  <script src="https://cdn.jsdelivr.net/npm/marked@15.0.8/lib/marked.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked-highlight@2.2.1/lib/index.umd.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.css" id="markdown-light">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.8.1/github-markdown-dark.css" id="markdown-dark" disabled>

  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/a11y-light.min.css" id="code-light">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/a11y-dark.min.css" id="code-dark" disabled>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.css" id="mermaid-light">
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>

  <script src="https://cdn.tailwindcss.com"></script>

  
  <style>
    /* 自定义样式 */

    html {
        scroll-behavior: smooth;
        overflow: hidden;
    }

    body.dark-mode .markdown-body {
        background-color: #444654;
        color: #ececf1;
    }

    .markdown-body {
        background-color: #f7f7f8;
    }

    .message-bubble {
      /* max-width: 85%; */
      max-width: fit-content;
      margin-bottom: 15px;
      padding: 12px 16px;
      border-radius: 8px;
      position: relative;
      word-break: break-word;
    }
    
    .user-message {
      background-color: #eeeeee; /* OpenAI绿色 */
      color: rgb(27, 27, 27);
      margin-left: auto;
      text-align: right;
    }
    
    .assistant-message {
      background-color: #f7f7f8;
      color: #222;
    }

    body.dark-mode .assistant-message {
      background-color: #444654;
      color: #ececf1;
    }
    
    /* 输入区域样式 */
    .input-area-container {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: white;
      padding: 15px 20px;
      border-top: 1px solid #e5e5e5;
      z-index: 100;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
    }
    
    .message-input {
      border-radius: 8px;
      padding: 12px 16px;
      resize: none;
      overflow-y: auto;
      max-height: 120px;
      flex-grow: 1;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      border: 1px solid #e2e8f0;
      transition: all 0.3s ease;
    }
    
    .message-input:focus {
      box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5);
      border-color: #4299e1;
      outline: none;
    }
    
    .send-button {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, #10a37f 0%, #0e8a6e 100%);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: all 0.2s ease;
      flex-shrink: 0;
      margin-top: 6px; /* 微调垂直对齐 */
    }
    
    .send-button:hover:not(:disabled):not(.loading) {
      transform: scale(1.05);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    
    .send-button:disabled {
      background: #cccccc;
      cursor: not-allowed;
    }
    /* 添加Loading状态样式 */
    .send-button.loading {
      background: #cccccc;
      cursor: pointer;
    }
    .send-button.loading span[uk-icon] {
      display: none;
    }
    .send-button.loading:before {
      content: '...';
      transition: all 0.5s ease;
    }


    
    /* 暗黑模式 */
    body.dark-mode {
      background-color: #202123;
      color: #ececf1;
    }
    
    body.dark-mode .bg-white {
      background-color: #343541 !important;
    }
    
    body.dark-mode .ai-message {
      background-color: #444654;
      color: #ececf1;
    }
    
    body.dark-mode .input-area-container {
      background-color: #343541;
      border-top-color: #4d4d4f;
    }
    
    body.dark-mode .message-input {
      background-color: #40414f;
      color: #ececf1;
      border-color: #565869;
    }
    
    body.dark-mode .uk-notification {
      background-color: #343541;
      color: #ececf1;
    }
    
    
    /* 添加自定义图标样式 */
    .theme-icon {
      width: 20px;
      height: 20px;
      display: block;
    }
    
    .theme-icon svg {
      width: 100%;
      height: 100%;
    }
    
    .moon-icon {
      display: block;
    }
    
    .sun-icon {
      display: none;
    }
    
    body.dark-mode .moon-icon {
      display: none;
    }
    
    body.dark-mode .sun-icon {
      display: block;
    }

    /* 历史对话抽屉样式 */
    .conversation-list {
      padding: 10px 0;
    }
    
    .conversation-item {
      display: flex;
      align-items: center;
      padding: 10px 15px;
      cursor: pointer;
      border-left: 3px solid transparent;
      transition: background-color 0.2s;
      border-bottom: 1px solid #eee;
    }
    
    body.dark-mode .conversation-item {
      border-bottom-color: #3a3a3f;
    }
    
    .conversation-item:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }
    
    body.dark-mode .conversation-item:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }
    
    .conversation-item.active {
      background-color: rgba(16, 163, 127, 0.1);
      border-left-color: #10a37f;
    }
    
    body.dark-mode .conversation-item.active {
      background-color: rgba(16, 163, 127, 0.2);
    }
    
    .conversation-title {
      flex-grow: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.95rem;
      max-width: 40%;
    }


    body.dark-mode #conversation-title {
      color: #ececf1;
    }


    
    body.dark-mode .conversation-date {
      color: #aaa;
    }
    
    .new-chat-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 15px;
      padding: 10px;
      border-radius: 5px;
      background-color: #10a37f;
      color: white;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .new-chat-btn:hover {
      background-color: #0e8a6e;
    }
    
    /* 暗黑模式适配 */
    body.dark-mode .uk-offcanvas-bar {
      background-color: #202123;
        color: #ececf1;
    }

    .uk-offcanvas-bar {
        background-color: #f9f9f9;
        color: #232323;
    }

    .uk-offcanvas-bar .uk-text-bold {
      color: #10a37f;
    }
    
    .uk-offcanvas-close {
      color: #d3d3d3!important;
    }

    body.dark-mode .uk-offcanvas-bar .uk-close {
      color: #ececf1;
    }
  </style>
</head>
<body class="bg-gray-10">
  <!-- 添加UIKit Offcanvas组件作为左侧抽屉 -->
  <div id="offcanvas-nav" uk-offcanvas="overlay: true; mode: push">
    <div class="uk-offcanvas-bar shadow-sm">
      <button class="uk-offcanvas-close" type="button" uk-close></button>
      <h3 class="uk-text-bold">对话历史</h3>
      
      <div class="new-chat-btn" id="new-chat-btn">
        <span uk-icon="icon: plus"></span>
        <span class="ml-2">新对话</span>
      </div>
      
      <div class="conversation-list" id="conversation-list"></div>
    </div>
  </div>

  <div id="app" class="flex flex-col h-screen">
    <!-- 顶部导航栏 - 添加菜单图标 -->
    <header class="bg-white shadow-sm">
      <div class="uk-container uk-container-expand">
        <nav class="uk-navbar" uk-navbar>
          <div class="uk-navbar-left">
            <!-- 添加菜单按钮 -->
            <a class="uk-navbar-toggle" href="#" uk-toggle="target: #offcanvas-nav">
              <span uk-icon="icon: menu"></span>
            </a>
            <!-- 将固定标题改为可编辑区域 -->
            <div class="uk-navbar-item">
              <span id="conversation-title" contenteditable="true"></span>
            </div>
          </div>
          <div class="uk-navbar-right">
            <ul class="uk-navbar-nav">
              <li>
                <a href="#" id="theme-toggle" class="theme-icon">
                  <span class="moon-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                  </span>
                  <span class="sun-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <circle cx="12" cy="12" r="5"></circle>
                      <line x1="12" y1="1" x2="12" y2="3"></line>
                      <line x1="12" y1="21" x2="12" y2="23"></line>
                      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                      <line x1="1" y1="12" x2="3" y2="12"></line>
                      <line x1="21" y1="12" x2="23" y2="12"></line>
                      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                  </span>
                </a>
              </li>
              <li>
                <a href="#" uk-icon="icon: cog"></a>
                <div class="uk-navbar-dropdown" uk-dropdown="mode: click; animation: uk-animation-slide-top-small; duration: 100">
                  <ul class="uk-nav uk-navbar-dropdown-nav line-height-2">
                    <li style="margin:16px;"><a id="clear-chat" uk-icon="icon: refresh">清空记录</a></li>
                    <li style="margin:16px;"><a id="remove-chat" uk-icon="icon: trash">删除对话</a></li>
                    <li style="margin:16px;"><a id="api-settings" uk-icon="icon: cog">对话设置</a></li>
                  </ul>
                </div>
              </li>
            </ul>
          </div>
        </nav>
      </div>
    </header>
    
    <!-- 聊天区域 -->
    <main class="flex-grow overflow-hidden pb-[100px]"> <!-- 添加底部padding以防止内容被输入区域遮挡 -->
      <div class="uk-container uk-container-expand h-full">
        <div id="chat-container" class="chat-container flex flex-col h-[calc(100vh_-_260px)] overflow-y-auto scroll-smooth mb-2.5 p-5"></div>
      </div>
    </main>
    
    <div class="input-area-container">

        <div class="message-toolbar uk-margin-small-bottom flex items-center gap-8">

            <div class="uk-inline">
                <div class="js-upload cursor-hand" uk-form-custom>
                    <button class="toolbar-btn" type="button" uk-tooltip="上传文件">
                        <span uk-icon="icon: image"></span>
                        <input type="file" id="image-upload-input" accept="image/*" multiple>
                    </button>

                </div>
            </div>
            
            <div class="uk-inline">
              <button class="toolbar-btn" id="mcp-toggle" uk-tooltip="MCP">
                <span uk-icon="icon: google"></span>
              </button>
            </div>
        
        </div>

        <div class="flex items-start gap-2.5 relative mx-auto my-0">
          <textarea id="message-input"  class="message-input uk-textarea" rows="1" placeholder="输入信息..." style="overflow:hidden"></textarea>
          <button id="send-button" class="send-button" disabled><span uk-icon="icon: arrow-right"></span></button>
        </div>

        <div id="image-preview-container" class="flex flex-wrap gap-2.5 mt-2.5">
            <ul class="uk-thumbnav" uk-margin id="image-preview-container"></ul>
        </div>
    </div>

  </div>
  
  <div id="settings-modal" uk-modal>
    <div class="uk-modal-dialog uk-modal-body">
      <h2 class="uk-modal-title">对话设置</h2>
      <form class="uk-form-stacked">
        <div class="uk-margin">
          <label class="uk-form-label">API Key</label>
          <div class="uk-form-controls"><input class="uk-input" id="api-key" type="password" placeholder="输入你的API Key"></div>
        </div>
        <div class="uk-margin">
            <label class="uk-form-label">MCP(SSE)</label>
            <div class="uk-form-controls"><input class="uk-input" id="mcp" type="text" placeholder="请输入MCP服务器地址"></div>
          </div>        
        <div class="uk-margin">
          <label class="uk-form-label">API baseURL</label>
          <div class="uk-form-controls"><input class="uk-input" id="baseURL" type="text" placeholder="https://porky.toai.chat/pollination/v1"></div>
        </div>
        <div class="uk-margin">
          <label class="uk-form-label">模型</label>
          <div class="uk-form-controls">
            <input class="uk-input" id="model" type="text" placeholder="模型名称" value="gemini">
          </div>
        </div>
        <div class="uk-margin">
          <label class="uk-form-label">系统提示 (System Prompt)</label>
          <div class="uk-form-controls">
            <textarea class="uk-textarea" id="systemPrompt" rows="3" placeholder="输入系统提示，指导AI的行为和角色"></textarea>
          </div>
        </div>
        <div class="uk-margin">
          <label class="uk-form-label">温度 <span id="temperature-value">0.7</span></label>
          <div class="uk-form-controls"><input class="uk-range" id="temperature" type="range" min="0" max="2" step="0.01" value="0.7"></div>
        </div>
        <div class="uk-margin">
          <label class="uk-form-label">最大令牌数 (Max Tokens)</label>
          <div class="uk-form-controls">
            <input class="uk-input" id="maxTokens" type="number" placeholder="最大令牌数" value="128000">
          </div>
        </div>
        <div class="uk-margin">
          <label class="uk-form-label">Top P <span id="top-p-value">1.0</span></label>
          <div class="uk-form-controls"><input class="uk-range" id="topP" type="range" min="0" max="1" step="0.01" value="1.0"></div>
        </div>
      </form>
      <div class="uk-text-right">
        <button class="uk-button uk-button-default uk-modal-close rounded-md">取消</button>
        <button class="uk-button uk-button-primary rounded-md" id="save-settings">保存</button>
      </div>
    </div>
  </div>

  <script>

    document.getElementById('theme-toggle').addEventListener('click', async () => {
        document.body.classList.toggle('dark-mode');
        const isDarkMode = document.body.classList.contains('dark-mode');
        document.getElementById('markdown-light').disabled = isDarkMode;
        document.getElementById('markdown-dark').disabled = !isDarkMode;
        document.getElementById('code-light').disabled = isDarkMode;
        document.getElementById('code-dark').disabled = !isDarkMode;
        localStorage.setItem('darkMode', isDarkMode);
    });

    const darkMode = localStorage.getItem('darkMode') === 'true';
    if (darkMode) {
      document.body.classList.add('dark-mode');
      document.getElementById('markdown-light').disabled = true
      document.getElementById('markdown-dark').disabled = false;
      document.getElementById('code-light').disabled = true
      document.getElementById('code-dark').disabled = false;
    }

    mermaid.initialize({startOnLoad:true, theme: darkMode ? 'neutral' : 'neutral', securityLevel: 'loose'});


class AI {
    constructor(options = {}) {
      this.api_key = options.api_key || options.apiKey || '';
      this.baseURL = options.baseURL || options.endpoint || 'https://porky.toai.chat/gemini/v1';
      this.completionsURI = options.completionsURI || 'chat/completions';
      this.model = options.model || 'gemini-2.0-flash';
      this.messages = options.messages || [];
      this.system_prompt = options.system_prompt || options.sysprompt || '';
      this.abortController = null;
      this.toolFn = options.tool_fn || options.mcpserver || null;
      this.opts = { temperature: 0.7, max_tokens: 128000, top_p: 1, stream: true, ...options.opts };
      this.completions = { create: this.create.bind(this) };
      this.filters = {}; // 存储消息过滤器
      
      // 添加默认过滤器
      this.add_response_filter('content', data => data.type === 'content' || (typeof data.content === 'string' && data.content));
      this.add_response_filter('reasoning_content', data => data.type === 'reasoning_content');
      this.add_response_filter('tool_calls', data => data.type === 'tool_calls');
      this.add_response_filter('tool_request', data => data.type === 'tool_request');
      this.add_response_filter('tool_response', data => data.type === 'tool_response');
      this.add_response_filter('final', data => data.type === 'final');
      
      return this;
      //return (async () => this)();
    }
    
    // 添加响应过滤器
    add_response_filter(queue_name, filterFn) {
      if (!this.filters[queue_name]) this.filters[queue_name] = [];
      this.filters[queue_name].push(filterFn);
      return this; // 支持链式调用
    }
    
    cancel() { if (this.abortController) { this.abortController.abort(); this.abortController = null; } }
    
    async create(prompt, args) {

      const { options={}, images=[], audio=[], files=[] } = args || {}

      const messages = [...(options.messages || this.messages || [])];
      if (this.system_prompt) messages.unshift({ role: 'system', content: this.system_prompt });
      if (prompt || images?.length || audio?.length || files?.length) 
        messages.push(this.prepareUserMessage(prompt, { images, audio, files }));
      
      const reqOptions = {
        model: options.model || this.model,
        messages,
        temperature: options.temperature || this.opts.temperature,
        max_tokens: options.max_tokens || this.opts.max_tokens,
        top_p: options.top_p || this.opts.top_p,
        stream: options.stream !== undefined ? options.stream : this.opts.stream,
        ...(this.toolFn?.tools && { tools: this.toolFn.tools, tool_choice: options.tool_choice || "auto" })
      };
      
      this.abortController = new AbortController();
      
      try {
        const response = await fetch(`${this.baseURL}/${this.completionsURI}`, {
          method: 'POST', 
          headers: {
            'Content-Type': 'application/json',
            ...(this.api_key ? { 'Authorization': `Bearer ${this.api_key}` } : {})
          },
          body: JSON.stringify(reqOptions),
          signal: this.abortController.signal
        });
        
        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          throw new Error(`API错误: ${response.status} ${error.error?.message || ''}`);
        }
        
        if (!reqOptions.stream) {
          const result = await response.json();
          return new ResponseIterator({ 
            type: 'final', 
            message: result.choices?.[0]?.message || { role: 'assistant', content: '' }, 
            ai: this, final: true,
            filters: this.filters // 传递过滤器
          });
        }
        
        const iter = new ResponseIterator({ ai: this, reqOptions, filters: this.filters }); // 传递过滤器
        this.processStream(response, iter);
        return iter;
      } catch (error) { throw error; }
    }
    
    async processStream(response, iter) {
      const reader = response.body.getReader(), decoder = new TextDecoder();
      const msg = { role: 'assistant', content: '', reasoning_content: '' };
      const toolCalls = [];
      let buffer = '', eventType = '', data = '', toolCallsFinalized = false;
      
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          let lines = buffer.split('\n');
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            const trimmed = line.trim();
            
            // 检测[DONE]标记
            if (trimmed === 'data: [DONE]') {
              if (!toolCalls.length) {
                iter.push('final', { type: 'final', message: msg });
                iter.complete();
              }
              continue;
            }
            
            if (trimmed === '') {
              if (data) {
                try { await this.handleEvent({ type: eventType || 'content', data: JSON.parse(data) }, 
                     msg, toolCalls, iter, toolCallsFinalized); } 
                catch(e) { await this.handleEvent({ type: eventType || 'content', data }, 
                          msg, toolCalls, iter, toolCallsFinalized); }
                data = ''; eventType = '';
              }
            } else if (trimmed.startsWith('event:')) eventType = trimmed.slice(6).trim();
            else if (trimmed.startsWith('data:')) data += trimmed.slice(5).trim();
            else if (!data && !eventType) data = trimmed;
          }
        }
        
        if (data) {
          // 检查是否为[DONE]标记
          if (data.trim() === '[DONE]') {
            if (!toolCalls.length) {
              iter.push('final', { type: 'final', message: msg });
              iter.complete();
            }
          } else {
            try { await this.handleEvent({ type: eventType || 'content', data: JSON.parse(data) }, 
                 msg, toolCalls, iter, toolCallsFinalized); } 
            catch(e) { await this.handleEvent({ type: eventType || 'content', data }, 
                      msg, toolCalls, iter, toolCallsFinalized); }
          }
        }
        
        // 处理流结束但没有显式[DONE]标记的情况
        if (!toolCallsFinalized && !iter.completed) {
          if (!toolCalls.length) {
            iter.push('final', { type: 'final', message: msg }); 
            iter.complete();
          } else if (toolCalls.every(t => t.function?.arguments)) {
            await this.handleToolCalls(msg, toolCalls, iter);
          }
        }
      } catch (error) { iter.error(error); 
      } finally { reader.releaseLock(); this.abortController = null; }
    }
    
    async handleEvent(event, msg, toolCalls, iter, toolCallsFinalized) {
      const { type, data } = event;
      const content = typeof data === 'object' ? 
        (data.choices?.[0]?.delta?.content || data.content || data.text || '') : data;
      
      // 使用通用事件处理方式
      if (content) {
        msg.content += content;
        const chunk = { type: 'content', content, message: {...msg}, delta: content };
        iter.push('streaming', chunk); // 只推送到streaming，让过滤器处理其他队列
        return;
      }
      
      switch (type) {
        case 'reasoning_content':
          msg.reasoning_content += data;
          iter.push('streaming', { type, content: data, message: {...msg}, delta: data });
          break;
        case 'tool_calls':
          this.updateToolCalls(data, toolCalls);
          iter.push('streaming', { type, toolCalls: [...toolCalls], message: {...msg}, delta: data });
          
          if (!toolCallsFinalized && toolCalls.length > 0 && 
              toolCalls.every(t => t.function?.arguments)) {
            return this.handleToolCalls(msg, toolCalls, iter);
          }
          break;
      }
    }
    
    async handleToolCalls(msg, toolCalls, iter) {
      msg.tool_calls = [...toolCalls];
      iter.push('tool_request', { type: 'tool_request', toolCalls, message: {...msg} });
      
      const results = !this.toolFn ? [] : await Promise.all(toolCalls.map(async tool => {
        try {
          const args = JSON.parse(tool.function.arguments);
          const result = await this.toolFn.execute(tool.function.name, args);
          return {
            tool_call_id: tool.id, role: "tool",
            content: typeof result === 'string' ? result : JSON.stringify(result)
          };
        } catch (err) { 
          return { tool_call_id: tool.id, role: "tool", content: JSON.stringify({ error: err.message }) }; 
        }
      }));
      
      iter.push('tool_response', { type: 'tool_response', toolResults: results, toolCalls });
      
      try {
        const nextResponse = await this.create("", { 
          ...iter.reqOptions,
          messages: [
            ...iter.reqOptions.messages, {...msg},
            ...results.map(r => ({ role: "tool", tool_call_id: r.tool_call_id, content: r.content }))
          ],
          tool_choice: "auto"
        });
        iter.chainWith(nextResponse);
      } catch (error) { iter.error(error); }
    }
    
    prepareUserMessage(message, { images, audio, files } = {}) {
      if ((!images?.length) && (!audio?.length) && (!files?.length)) 
        return { role: "user", content: message };
      
      const content = [];
      if (message?.trim()) content.push({ type: "text", text: message });
      
      if (images?.length) images.forEach(img => content.push({
        type: "image_url", image_url: { url: img.url || img, detail: img.detail || "auto" }
      }));
      
      if (audio?.length) audio.forEach(clip => 
        content.push({ type: "audio", audio: { url: clip.url || clip } }));
      
      if (files?.length) files.forEach(file => 
        content.push({ type: "file", file: { url: file.url || file } }));
      
      return { role: "user", content };
    }
    
    updateToolCalls(deltas, toolCalls) {
      deltas.forEach(d => {
        const idx = d.index;
        if (!toolCalls[idx]) toolCalls[idx] = { 
          id: d.id || '', type: 'function', function: { name: '', arguments: '' } };
        if (d.id) toolCalls[idx].id = d.id;
        if (d.function?.name) toolCalls[idx].function.name = d.function.name;
        if (d.function?.arguments) toolCalls[idx].function.arguments += d.function.arguments;
      });
    }
  }

  class ResponseIterator {
    constructor({ ai, reqOptions, type, message, final = false, filters = {} }) {
      this.ai = ai; this.reqOptions = reqOptions;
      this.queues = new Map(); this.waiters = new Map();
      this.chained = null; this.completed = false;
      this.filters = filters; // 存储过滤器
      
      // 基本队列加上过滤器中定义的自定义队列
      const queueTypes = [
        'content', 'reasoning_content', 'tool_calls', 'tool_request', 
        'tool_response', 'streaming', 'final', ...Object.keys(filters)
      ];
      
      // 创建所有队列
      queueTypes.forEach(t => {
        if (!this.queues.has(t)) {
          this.queues.set(t, []);
          this.waiters.set(t, []);
        }
      });
      
      if (final && type && message) { this.push(type, { type, message }); this.complete(); }
    }
    
    push(type, data) {
      if (this.completed) return;
      
      // 处理基本队列
      const queue = this.queues.get(type) || [], waiters = this.waiters.get(type) || [];
      queue.push(data); 
      if (waiters.length) waiters.shift()();
      
      // 应用自定义过滤器
      Object.keys(this.filters).forEach(queueName => {
        const filterFns = this.filters[queueName];
        if (Array.isArray(filterFns)) {
          // 如果任何过滤器返回true，将此数据添加到相应队列
          if (filterFns.some(fn => fn(data))) {
            const customQueue = this.queues.get(queueName);
            const customWaiters = this.waiters.get(queueName);
            if (customQueue) {
              customQueue.push(data);
              if (customWaiters && customWaiters.length) customWaiters.shift()();
            }
          }
        }
      });
    }
    
    complete() {
      this.completed = true;
      for (const waiters of this.waiters.values()) waiters.forEach(r => r());
    }
    
    chainWith(r) { this.chained = r; this.complete(); }
    error(e) { this.errorObj = e; this.complete(); }
    
    on(type) {
      if (!this.queues.has(type)) throw new Error(`未知事件类型: ${type}`);
      const self = this;
      
      return {
        async *[Symbol.asyncIterator]() {
          try {
            if (self.errorObj) throw self.errorObj;
            let queue = self.queues.get(type), index = 0;
            
            while (true) {
              if (index >= queue.length) {
                if (self.completed && !self.chained) break;
                if (self.chained) { 
                  for await (const item of self.chained.on(type)) yield item;
                  break;
                }
                
                await new Promise(r => self.waiters.get(type).push(r));
                if (self.errorObj) throw self.errorObj;
                queue = self.queues.get(type);
              } else yield queue[index++];
            }
          } catch (e) { throw e; }
        }
      };
    }
    
    async *[Symbol.asyncIterator]() { yield* this.on('streaming'); }
  }


    class DataBase {
      constructor(dbname, structure={}) {
        this.dbName = dbname
        this.structure = structure;
        this.db = null;
        this.ready = this.initDatabase();
      }

      async initDatabase() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, 1);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            for (const storeName in this.structure) {
              if (!db.objectStoreNames.contains(storeName)) {
                const store = db.createObjectStore(storeName, { keyPath: this.structure[storeName].keyPath });
                for (const index of this.structure[storeName].indexes) {
                  store.createIndex(index.name, index.keyPath, { unique: index.unique||false });
                }
              }
            }
          };
    
          request.onsuccess = (event) => { this.db = event.target.result; resolve(true);};
          request.onerror = (event) => { reject(event.target.error);};
        });
      }

      async getCollectionData(collection, key, filter) {
        await this.ready;
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([collection], 'readonly');
          const store = transaction.objectStore(collection);
          const index = store.index(key);
          const request = !filter ? index.getAll() : index.getAll(filter);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      async setCollectionData(collection, data) {
        await this.ready;
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([collection], 'readwrite');
          const store = transaction.objectStore(collection);
          const request = store.put(data);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      async deleteCollectionData(collection, key) {
        await this.ready;
        return new Promise((resolve, reject) => {
          const transaction = this.db.transaction([collection], 'readwrite');
          const store = transaction.objectStore(collection);
          const request = store.delete(key);
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }
    }
      
    class MainDatabase extends DataBase {
        constructor() {
          super('MainDB', {
            conversations: {
              keyPath: 'id',
              indexes: [
                { name: 'title', keyPath: 'title' },
                { name: 'lastMessage', keyPath: 'lastMessage' },
                { name: 'id', keyPath: 'id' },
                { name: 'timestamp', keyPath: 'timestamp' }
              ]
            }
          });
        }
        async getAllConversations(id=null) {
          if (id) return await this.getCollectionData('conversations', 'id', id);
          return await this.getCollectionData('conversations', 'timestamp');
        }
        async getOrCreateLastChat() {
          const conversations = await this.getAllConversations();
          if (conversations.length > 0) {
            const conversation = conversations[conversations.length - 1];
            console.log('获取最后一个对话:', conversation);
            return conversation;
          }
          return this.createNewConversation(Date.now(), '');
        }
        async createNewConversation(id, title) {
          const conversation = {
            id: id, title: title,
            timestamp: Date.now(), lastMessage: ''
          };
          console.log('创建新的对话:', conversation);
          await this.setCollectionData('conversations', conversation);
          return conversation;
        }
      }

    class ChatDatabase extends DataBase {
      constructor(chatId) {
        if(!chatId) {
          debugger;
          throw new Error('Chat ID is required');
        }
        super(`ChatDB-${chatId}`, {
          messages: {
            keyPath: 'id',
            indexes: [
              { name: 'id', keyPath: 'id' },
              { name: 'content', keyPath: 'content' },
              { name: 'role', keyPath: 'role' },
              { name: 'timestamp', keyPath: 'timestamp' },
              { name: 'images', keyPath: 'images' }
            ]
          },
          settings: {
            keyPath: 'key',
            indexes: [
              { name: 'key', keyPath: 'key' },
              { name: 'value', keyPath: 'value' }
            ]
          }
        });
      }
      async getSettings() {return await this.getCollectionData('settings', 'key')}
      async saveMessage(message) { await this.setCollectionData('messages', message)}
      async getAllMessages() { return await this.getCollectionData('messages', 'timestamp') }
    }

    window.MainDatabase = new MainDatabase()


    class AdvancedConversation {
      constructor() {
        this.db = window.MainDatabase
        this.conversationList = document.getElementById('conversation-list');
        this.newChatButton = document.getElementById('new-chat-btn');
        this.deleteChatButton = document.getElementById('remove-chat');
        this.topicTitle = document.getElementById('conversation-title');
        this.init();
      }
      async init() {
        this.newChatButton.addEventListener('click', this.createNewConversation.bind(this));
        await this.loadConversations();
        this.deleteChatButton.addEventListener('click', this.deleteConversation.bind(this));
        this.topicTitle.addEventListener('blur', async (e) => {
          const title = e.target.innerText;
          if (title) { await this.setConversationTitle(window.aiui.chatId, title);}
        });
        this.topicTitle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); this.topicTitle.blur();}
        });
      }
      async loadConversations() {
        const conversations = await this.db.getAllConversations();
        this.conversationList.innerHTML = ''; // 清空列表
        for (const conversation of conversations) {
          const item = document.createElement('div');
          item.className = 'conversation-item';
          item.id = 'conversation-' + conversation.id;
          item.setAttribute('data-id', conversation.id);
          item.innerHTML = `<span class="conversation-title">${conversation.title||'Untitled Topic'}</span><span class="conversation-date">${new Date(conversation.timestamp).toLocaleString()}</span>`;
          item.addEventListener('click', (e) => {this.loadConversation(conversation.id);});
          this.conversationList.appendChild(item);
        }
      }
      async createNewConversation() {
        const chat = await this.db.createNewConversation(Date.now(), '');
        await this.loadConversations();
        await this.loadConversation(chat.id);
      }
      async loadConversation(id) {
        await this.loadConversations()
        const conversations = await this.db.getAllConversations(id);
        if (conversations.length > 0) {
          const conversation = conversations[0];
          this.conversationList.querySelectorAll('.conversation-item').forEach(item => item.classList.remove('active'));
          this.conversationList.querySelector(`#conversation-${conversation.id}`).classList.add('active');
          window.aiui = new AIUI( {chatId: conversation.id} );
          await window.aiui.ready;
          this.topicTitle.innerText = conversation.title;
          UIkit.offcanvas('#offcanvas-nav').hide();
        }
      }
      async deleteConversation(event) {
        const id = window.aiui.chatId;
        await UIkit.modal.confirm('确定要删除此对话吗？', {labels: {ok: '删除', cancel: '取消'}}).then(async () => {
          await this.db.deleteCollectionData('conversations', id);
          await indexedDB.deleteDatabase(`ChatDB-${id}`);
          await this.loadConversations();
          window.aiui = new AIUI();
        })
      }
      async setConversationTitle(id, title) {
        const conversation = await this.db.getCollectionData('conversations', 'id', id);
        if (conversation.length > 0) {
          conversation[0].title = title;
          await this.db.setCollectionData('conversations', conversation[0]);
          this.topicTitle.innerText = title;
        }
        await this.loadConversations();
      }
    }


    class AdvancedContainer {
      // 聊天消息容器类，主要控制chat-container的消息
      constructor(db) {
        this.container = document.getElementById('chat-container');
        this.clearChatButton = document.getElementById('clear-chat');
        this.container.innerHTML = ''; // 初始化的时候，清空容器
        this.db = db;
        this.ready = this.init()
      }

      async init() {
        this.clearChatButton.addEventListener('click', async() => {
          await UIkit.modal.confirm('确定要清空聊天记录吗？', {labels: {ok: '清空', cancel: '取消'}}).then(async () => {
            await this.clearChat();window.aiui.ai.messages = [];
          });
        });
      }

      scrollToBottom() {this.container.scrollTop = this.container.scrollHeight;}
      
      async newMessage(role) {
        const msgId = `msg-${Date.now()}`;
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message-bubble shadow-sm';
        messageDiv.classList.add(`${role}-message`);
        messageDiv.id = msgId;

        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        messageContent.setAttribute('raw', '');
        if (role === 'assistant') {
            messageContent.setAttribute('class','message-content px-4 py-2 markdown-body rounded-md');
        }

        const messageReason = document.createElement('div');
        messageReason.className = 'message-reason';
        messageReason.setAttribute('raw', '');

        messageDiv.appendChild(messageReason);
        messageDiv.appendChild(messageContent);

        const add = () => { this.container.appendChild(messageDiv); this.scrollToBottom();};
        const update = async(content,  scroll=false, images=[]) => { 
          messageContent.setAttribute('raw', content);
          if (role === 'user') {
            messageContent.innerHTML = content;
            if (images.length) {
                messageContent.setAttribute('images', JSON.stringify(images));
                const imgContainer = document.createElement('div'); imgContainer.className = 'flex';
                images.forEach((image, index) => {
                    const img = document.createElement('img');
                    img.src = image; img.style.height = '80px'; img.className = 'rounded-md mx-0.5'; 
                    imgContainer.appendChild(img);
                });
                messageContent.appendChild(imgContainer);
            }
          } else if (role==='assistant') {
            messageContent.innerHTML = marked.parse(content);
          }

          if (role === 'assistant') {setTimeout(() => mermaid.init(undefined, messageContent.querySelectorAll('.mermaid')), 0);}
          if (scroll) this.scrollToBottom();
        };
        const updateReason = async(reason) => {
          messageReason.innerHTML = reason; messageDiv.appendChild(messageReason);
        }; 
        const save = async( ) => { 
            console.log(messageContent.getAttribute('images'))
            await this.db.saveMessage({ id: msgId,  role: role, content: messageContent.getAttribute('raw'), timestamp: Date.now(), images: messageContent.getAttribute('images') });
        };
        return {msgId, messageDiv, add, update, save, updateReason };
      }

      async clearChat() {
        const messages = await this.db.getAllMessages();
        for (const message of messages) { await this.db.deleteCollectionData('messages', message.id); }
        this.container.innerHTML = ''; 
      }

      async loadMessages() {
        const messages = await this.db.getAllMessages();
        for (const message of messages) {
          const { msgId, messageDiv, add, update } = await this.newMessage(message.role);
          await update(message.content, false, message.images ? JSON.parse(message.images) : []);
          add();
        }
      }
    }

    class AdvancedInput {
      // 聊天输入框类，主要控制message-input的输入, 以及发送按钮的状态， 还有点击发送按钮后的回调
      constructor() {
        this.input = document.getElementById('message-input');
        this.sendButton = document.getElementById('send-button');
        this.imageUploadInput = document.getElementById('image-upload-input');
        this.imagePreviewContainer = document.getElementById('image-preview-container');
        this.mcpToggle = document.getElementById('mcp-toggle');
        this.mcpcli = null;
        this.isProcessing = false;
        this.init()
      }

      init() {
        this.mcpToggle.addEventListener('click', this.mcpClient.bind(this));
        this.input.addEventListener('input', () => {
          this.sendButton.disabled = !this.input.value.trim();
          this.input.style.height = 'auto';
          this.input.style.height = Math.min(this.input.scrollHeight, 200) + 'px';
        });
        this.input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && e.ctrlKey) {e.preventDefault();this.sendButton.click();}
        });
        this.imageUploadInput.addEventListener('change', (e)=>{
            const files = e.target.files;
            if (files.length > 0) {
                for (const file of files) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const a = document.createElement('a');
                    a.className = 'uk-position-relative';
                    const img = document.createElement('img');
                    img.src = event.target.result; img.classList.add('rounded-md'); img.style.height='64px'
                    a.appendChild(img);
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'uk-icon-button uk-position-top-right uk-position-small';deleteBtn.setAttribute('uk-icon', 'trash');
                    deleteBtn.style.backgroundColor = 'rgba(255,255,255,0.4)';deleteBtn.onclick = (e) => {e.preventDefault(); a.remove();};
                    a.appendChild(deleteBtn);
                    this.imagePreviewContainer.appendChild(a);

                };
                reader.readAsDataURL(file);
                }
            }
        })
        this.sendButton.onclick = () => {
          if (this.isProcessing && this.sendButton.classList.contains('loading')) return             //return this.cancelCurrentRequest();
          if(!this.input.value.trim()) { return }
          this.isProcessing = true;
          this.sendButton.classList.add('loading');
          this.sendButton.disabled = false;
          return new Promise((resolve, reject) => {
            const message = { content: this.input.value, images: [...document.getElementById('image-preview-container').querySelectorAll('img')].map(x=>x.src) };
            window.aiui.onSendMessage(message, resolve, reject);
            this.isProcessing = false;
          }).catch((error) => {
            this.isProcessing = false;
            console.error('Error:', error);
          }).finally(() => {
            this.input.value = '';
            this.imagePreviewContainer.innerHTML = '';
            this.imageUploadInput.files = null;
            this.input.style.height = 'auto';
            this.sendButton.classList.remove('loading');
            this.sendButton.disabled = !this.input.value.trim();
          });
        };
      }

      async mcpClient() {
          // 已经实现了，但是我还不准备在这里放放
      }
    }

    class AdvancedSettings {
      constructor(db) {
        this.db = db;
        this.settingsButton = document.getElementById('api-settings');
        this.saveButton = document.getElementById('save-settings');
        this.settingsModal = document.getElementById('settings-modal');
        this.settings = {}
        this.init()
      }

      async init() {
        this.settingsButton.addEventListener('click', this.open.bind(this));
        this.saveButton.addEventListener('click', this.save.bind(this));
        document.getElementById('temperature').addEventListener('input', (e) => {
          document.getElementById('temperature-value').textContent = e.target.value;
        });
        document.getElementById('topP').addEventListener('input', (e) => {
          document.getElementById('top-p-value').textContent = e.target.value;
        });
        await this.get();
      }
      
      async open() {
        const settings = await this.get();
        document.getElementById('api-key').value = settings.apiKey || '';
        document.getElementById('baseURL').value = settings.baseURL || 'https://porky.toai.chat/pollination/v1';
        document.getElementById('model').value = settings.model || 'gemini';
        document.getElementById('systemPrompt').value = settings.systemPrompt || '';
        document.getElementById('temperature').value = settings.temperature || 0.7;
        document.getElementById('temperature-value').textContent = settings.temperature || 0.7;
        document.getElementById('maxTokens').value = settings.maxTokens || 128000;
        document.getElementById('topP').value = settings.topP || 1.0;
        document.getElementById('top-p-value').textContent = settings.topP || 1.0;
        UIkit.modal(this.settingsModal).show();
      }
      
      close() { UIkit.modal(this.settingsModal).hide();}

      async save() {
        for (const setting of ['api-key', 'mcp', 'baseURL', 'model', 'systemPrompt', 'temperature', 'maxTokens', 'topP']) {
          await this.db.setCollectionData('settings', { key: setting, value: document.getElementById(setting).value });
        }
        UIkit.notification({message: '设置已保存',status: 'success',pos: 'top-center',timeout: 2000});
        this.close();
        return await this.get();
      }

      async get() {
        const default_settings = {
            'api-key': '','baseURL': 'https://porky.toai.chat/pollination/v1',
            'model': 'gemini','systemPrompt': '',
            'temperature': 0.61,
            'maxTokens': 128000,
            'topP': 0.95
        }
        const saved_settings = (await this.db.getSettings()).reduce((acc, setting) => {acc[setting.key] = setting.value;return acc;}, {});
        this.settings = {...default_settings, ...saved_settings};
        return this.settings;
      }
    }

    // AIUI类
    class AIUI {
      constructor(options = {}) {        
        this.chatId = options.chatId
        this.ready = this.init()
      }

      async init() {
        if (!this.chatId) {
          const chat = await window.MainDatabase.getOrCreateLastChat();
          await window.conversations.loadConversation(chat.id);
          return
        }
        this.db = new ChatDatabase(this.chatId);
        this.container = new AdvancedContainer(this.db);
        this.input = new AdvancedInput();
        this.settings = new AdvancedSettings(this.db);
        await this.settings.get();

        const messages = (await this.db.getAllMessages()).map(m => ({role:m.role, content:m.content}));
        this.ai = new AI({
          messages: messages,
          system_prompt: this.settings.settings.systemPrompt || '',
          model: this.settings.settings.model,
          apiKey: this.settings.settings['api-key'] || '',
          baseURL: this.settings.settings.baseURL,
          opts: {
            temperature: parseFloat(this.settings.settings.temperature) || 0.7,
            max_tokens: parseInt(this.settings.settings.maxTokens) || 128000,
            top_p: parseFloat(this.settings.settings.topP) || 1.0
          }
        });
        await this.container.loadMessages();
      }
      
      async onSendMessage(message, resolve, reject) {
        const { content, images } = message;
        if (!content.trim()) {reject('消息不能为空');return}
        if (window.conversations.topicTitle.innerText === '') {
          await window.conversations.setConversationTitle(this.chatId, content.slice(0, 30));
        }
        const userMessage = await this.container.newMessage('user');
        await userMessage.add();
        await userMessage.update(content.trim(), true, images);
        await userMessage.save();

        const assistantMessage = await this.container.newMessage('assistant');
        await assistantMessage.add();
        await assistantMessage.update('<div uk-spinner></div>');
      
        try {
          // 调用AI生成回复
          this.currentResponse = await this.ai.create(content.trim(), {images: images});
          let fullResponse = '';
          
          // 处理流式响应
          for await (const chunk of this.currentResponse.on('content')) {
            if (chunk.delta) {
              fullResponse += chunk.delta;
              await assistantMessage.update(fullResponse, true);
            }
          }
          await assistantMessage.save();
          resolve(fullResponse);
        } catch (error) {
          await assistantMessage.update('抱歉，哪里出现了错误了。 请稍后再试。');
          reject(error);
        } 
      }
    }

    document.addEventListener('DOMContentLoaded', async function() {
      
        const { markedHighlight } = window.markedHighlight;
        marked.use(markedHighlight({
            langPrefix: 'hljs language-',
            highlight: function(code, lang) {
                if (lang === 'mermaid') {
                    return '<div class="mermaid">' + code + '</div>';
                }
                const language = hljs.getLanguage(lang) || 'plaintext';
                return hljs.highlight(code, {language: lang}).value;
            }
        }));

        window.conversations = new AdvancedConversation();
        await window.conversations.loadConversations();
        window.aiui = new AIUI();
        await window.aiui.ready

        window.scrollTo(0, 1);
        document.body.requestFullscreen()

    });
  </script>
</body>
</html>
